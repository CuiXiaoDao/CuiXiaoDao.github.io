---
layout: post
title: 2024-09-09-从一次HTTP请求看TCP IP协议
categories: network
description: 
keywords: network
---
这篇笔记的目的通过分析一次HTTP请求，梳理常见的TCP/IP协议，温故而知新

![](/assets/images/2024-09-09-从一次HTTP请求看TCP%20IP协议/image-20240913220214988.png)


## 发起一次HTTP请求

打开Chrome -> 开发者工具 -> Network，再访问常见的网页，比如zoom.us, 就可以看到一个HTTP请求及其回复。

要从本机（浏览器）发送一个HTTP请求，首先要确定，这个请求发给哪台主机。这里我们使用域名，请求过程中会通过DNS将域名换成某台目标服务器的IP地址，这就是这次通信的目标主机，也就是下面截图中的Remote Address。

![](/assets/images/2024-09-09-从一次HTTP请求看TCP%20IP协议/image-20240909214444008.png)

这台主机上可能有多个应用程序，不通应用之前通过端口区分，端口，也就是TCP层的地址。我们要发送给提供HTTP(S)服务的应用，默认是443端口。

HTTP请求报文一般包括以下要素
- Method：如POST/GET/DELETE
- Path: 指定要访问的资源，接口
- Http版本号，目前大多数网站使用的是Http/1.1
- 请求header
	- 包括一些业务自定义的header，如截图中的:authority, :method
	- 一些约定的header, 如Cookie, Accept等。指定了Client接受的内容歌手、编码、语言、压缩算法。
- Body


HTTP协议格式如下图所示

![](/assets/images/2024-09-09-从一次HTTP请求看TCP%20IP协议/image-20240911232041901.png)

请求报文示例如下

```
POST /contact_form.php HTTP/1.1
Host: developer.mozilla.org
Content-Length: 64
Content-Type: application/x-www-form-urlencoded

name=Joe%20User&request=Send%20me%20one%20of%20your%20catalogue
```


请求报文经过编码后变成字节流，分段后交由TCP层传输到目标主机。

目前大部分网站都使用HTTPS协议，它其实是在HTTP的基础上，在传输层使用TLS加密，来达到安全通信的目标。发送HTTPS请求时首先要进行TLS握手。TLS握手的流程，简单说，先利用证书进行非对称加密的通信，协商一个对称加密的秘钥，后续通信使用对称加密的秘钥。这样做可以兼顾非对称加密的安全性和对称加密的高性能。TLS握手完成后，会生成会话ID、会话ticket等，后续HTTPS请求可以通过这些信息直接使用上次的对称加密秘钥，不用重新握手。关TLS握手的细节可以参考 [TLS 1.0 至 1.3 握手流程详解](https://www.cnblogs.com/enoc/p/tls-handshake.html "发布于 2022-03-22 18:24")

![](/assets/images/2024-09-09-从一次HTTP请求看TCP%20IP协议/image-20240913224224758.png)


![](/assets/images/2024-09-09-从一次HTTP请求看TCP%20IP协议/image-20240913222831147.png)


## 传输层（TCP协议）

TCP协议处于传输层，负责将**一批**数据可靠的传送到目标主机。和IP层不同，IP层解决的是如何将单个数据包发送到目标主机，不包括可靠性。

TCP协议为了**保证可靠**，每个请求都需要接收方的**确认**。如果超时没收到确认，发送端需要重发。

这引出一个问题，如果每次都需要等上一个数据包被确认，才发出下一个数据包，等待时间太长、没有充分利用网络带宽 => RTT越长，性能越差。为了避免这个问题，TCP协议引入了**窗口**概念。窗口内，不需要等上一个数据包被确认，就可以发出下一个数据包，这样可以提高并发、减少等待时间。

但窗口带来两个新的问题
1. 并发发送，可能包会乱序。
2. 窗口大小如何确定。窗口太小，就不能充分利用网络带宽；窗口太大，可能加剧网络拥堵，大量丢包，反而让性能下降。

针对问题1，需要对每个数据包进行**编号**。针对问题2，TCP协议通过窗口控制和拥塞控制解决。

TCP的首部信息如下所示，对应上述提到的编号、确认、窗口等概念。此外，源端口号与目标端口号对应着“传输层的地址”，通过端口号区分，使用TCP协议的众多应用中、当前数据是发给谁的。
![](/assets/images/2024-09-09-从一次HTTP请求看TCP%20IP协议/image-20240912235640045.png)


## 网络层（IP协议)

TCP的数据加上IP首部后，经路由选择、转发到达目标主机。这一过程在网络层，参与的协议主要包括IP协议，ARP协议。


IPv4和Ipv6首部格式如下
![](/assets/images/2024-09-09-从一次HTTP请求看TCP%20IP协议/image-20240913000244793.png)
![](/assets/images/2024-09-09-从一次HTTP请求看TCP%20IP协议/image-20240913000310967.png)

源地址和目标地址定义了这个IP包从哪来，到哪去。IP包在网络上由经过的每个主机上的路由表，确定这个IP包的下一站是哪个主机、需要经当前主机的哪个网络接口到达。主机上的路由表由RIP、OSPF、BGP等路由协议维护更新。


谈到IP层，就不得不提NAT，由于IPv6尚未普及、IP地址不够，我们的网络设备（电脑，手机，手表）所分配到的只是一个本地网络地址，使用互联网时往往公用一个全局IP地址，也就是常说的公网IP、出口IP。这里利用的就是NAT技术。即使IPv6普及，每个网络设备都能有一个全局IP，处于网络管理的角度考虑，组织内往往还会使用NAT。

NAT简单说就是有这样一个设备，它叫NAT路由器，由内部网络发往互联网IP包，其源地址会被替换为NAT路由器的全局IP，IP负载中TCP首部的源端口会被替换为NAT路由器的某一空闲端口（可能时随机分配的，也可能是按某一策略分别的）。NAT路由器会缓存下这个空闲端口对应的内部网络的原始源地址和端口。

外部互联网收到IP包后，其回复会发往NAT路由器。回复的IP包其目标地址就是NAT路由器的全局地址，其目标端口是替换的空闲端口。NAT路由器会根据该目标端口从缓存中拿到内部网络的原始源地址和端口，并进行替换。替换后的IP包，能正确抵达内部网络的主机。

在这一个过程中，NAT对通信双方是透明的，通过NAT，内部网络的主机即使没有全局地址也能与互联网进行通信。但需要注意的是，这种通信只能有内部网络主动发起。互联网上的主机无法主动与内部网络的主机进行通信，无法设置IP包的目标地址为内部网络的主机。

网络层常涉及的协议还有
- ICMP：辅助IP协议，进行网络诊断，如IP包是否能到达目标主机、失败原因。我们常用的Ping命令就是基于该协议。
- DHCP：动态IP地址分配
- ARP：由IP地址，获取链路层MAC地址


## 链路层

通过路由表，我们得知每个IP包的下一跳是哪个IP，改由当前主机的哪个网络接口发出。这个下一跳的主机，就是链路层的一个目的地。IP层负责让数据包在从起点到目标主机，而链路层负责让数据包到达下一站。以单车旅行为例，IP层负责的是从杭州到北京的，而链路层负责的是从杭州到上海，从上海到天津，再从天津到北京这一段段的起点和终点间的旅程。而TCP协议，则是第一次半途而废后，我会再次尝试。


链路层使用MAC地址作为目的地。为什么我们不能使用MAC地址作为互联网的通信地址呢，我觉得主要原因是MAC地址是有硬件厂家设置的、销往各地，不能像普通地址一样是分层的、每一层能用于寻址。IP地址类似我们的邮递地址，“浙江省杭州市XX区”，地址的每一部分都在逐级的缩小范围、都能用于寻址，并最终定位到目的地。

下一跳主机的IP地址到MAC地址的转换，由ARP协议完成。目标主机收到后，由IP层确定是不是最终目的地，是，则再交由上层处理；不是，则根据路由表确定下一跳的目的地，再继续互联网的旅程，直到达到最终目的地。

## 应用处理
目标主机收到数据后，层层解包，去除首部，数据最终从链路层抵达应用层，由提供HTTP服务的应用收到请求报文，进行处理，产生回复数据。回复数据包的目标IP是发送主机IP，端口是请求数据包的TCP端口（该端口其实就是浏览器在监听的端口，一般有系统随机分配）。经过类似的流程，回复数据会抵达请求主机的浏览器应用程序，并向用户程序内容。